
#include "stm32f10x.h"
#include "system.h"
#include "modbus.h"



#define ADC1_DR_Address    				((u32)0x40012400+0x4c)// Адрес регистра результата преобразования АЦП
#define DMA_BUFF_SIZE 					200					// Размер буфера




unsigned int delay_packet = 0;								// задержка между пакетами. будет равна 7, что значит 1,75 мс
char flag_UART_in = 0;										// флаг начала приёма посылки по UART
char swith_modbas = 0;										// переменная переключатель для разбора посылки

int 			array_modbas_in[255];						// буфер для приёма из уарта
int 			count_modbas_in 		= 0;				// счётчик кол-ва принятых байт
int 			array_modbas_out[255];						// буфер для передачи из уарта
int 			count_modbas_out 		= 0;				// счётчик кол-ва переданных байт
int 			buffer_index			= 0;				// счётчик для отправки
int 			count_transf_array 		= 0;				// счётчик для перегрузки массивов

unsigned short	array_mb[100]			= {};				// массив для хранения принятых/переданных слов

unsigned long 	crc_calc 				= 0;				// расчётная контрольная сумма
unsigned long 	adrr_var 				= 0;				// собраный адрес из массива принятого по сети. для сравнения.
unsigned long 	quantity_byte 			= 0;				// кол-во байт которое необходимо записать или считать по сети из памяти

unsigned int 	crc_read_low 			= 0;				// буферные переменные для сравнение контрольной суммы
unsigned int 	crc_read_high 			= 0;				//
unsigned int 	crc_calc_low 			= 0;				//
unsigned int 	crc_calc_high 			= 0;				//




unsigned short dma_adc[DMA_BUFF_SIZE] = {}; 	// буферный массив для приёма данных из ацп через дма
unsigned long adc_buf[5] = {}; 					// буферный массив для усреднения


void ADC1_2_IRQHandler(void)
{
    if(ADC1->SR & ADC_SR_EOC)
	{

	}

	ADC1->SR=0;											//сбрасываем все флаги в регистре статуса
}



void DMA1_Channel1_IRQHandler(void)
{
	uint32_t buf =  DMA1->ISR;





	if( DMA1->ISR & DMA_ISR_HTIF1)						// если пришёл полубуфер буфер
	{

	}




	if( DMA1->ISR & DMA_ISR_TCIF1)						// если пришёл полный буфер
	{

	}

	DMA1->IFCR = buf;
}


			

int main(void)
{
    InitClk();

    init_modbus();


	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN; 				// Разрешить тактирование порта A

	// Сконфигурировать PORTA.0 как аналоговый вход
	GPIOA->CRL &= ~GPIO_CRL_MODE0; 						// Очистить биты MODE
	GPIOA->CRL &= ~GPIO_CRL_CNF0; 						// Очистить биты CNF

	// Сконфигурировать PORTA.1 как аналоговый вход
	GPIOA->CRL &= ~GPIO_CRL_MODE1; 						// Очистить биты MODE
	GPIOA->CRL &= ~GPIO_CRL_CNF1; 						// Очистить биты CNF

	// Сконфигурировать PORTA.2 как аналоговый вход
	GPIOA->CRL &= ~GPIO_CRL_MODE2; 						// Очистить биты MODE
	GPIOA->CRL &= ~GPIO_CRL_CNF2; 						// Очистить биты CNF

	// Сконфигурировать PORTA.3 как аналоговый вход
	GPIOA->CRL &= ~GPIO_CRL_MODE3; 						// Очистить биты MODE
	GPIOA->CRL &= ~GPIO_CRL_CNF3; 						// Очистить биты CNF

	// Сконфигурировать PORTA.4 как аналоговый вход
	GPIOA->CRL &= ~GPIO_CRL_MODE4; 						// Очистить биты MODE
	GPIOA->CRL &= ~GPIO_CRL_CNF4; 						// Очистить биты CNF


	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN; 				// Включить тактирование АЦП


	//Настроить делитель для ADC
	RCC->CFGR &= ~RCC_CFGR_ADCPRE;             //Очистка битов предделителя "ADC Prescaler"
	RCC->CFGR |=  RCC_CFGR_ADCPRE_DIV6;        //Установить "ADC Prescaler" равным 6

	ADC1->CR1 = 0; 										// Обнулить регистр управления
	ADC1->SQR1 = 0; 									// Обнулить регистр SQR1
	ADC1->CR2 |= ADC_CR2_CAL; 							// Пуск калибровки

	while (!(ADC1->CR2 & ADC_CR2_CAL)){}; 				// Ждать окончания калибровки


//	ADC1->SQR1 = 0x00300000;							// 00000000 0011 00011 00010 00001 00000	// 4 канала с 0 по 3.
//	ADC1->SQR2 = 0x00000000;
//	ADC1->SQR3 = 0x00018820;


	RCC->AHBENR |= RCC_AHBENR_DMA1EN; 					// Разрешаем тактирование первого DMA модуля
	DMA1_Channel1->CPAR = ADC1_DR_Address; 				// Указываем адрес периферии - регистр результата преобразования АЦП для регулярных каналов
	DMA1_Channel1->CMAR = (uint32_t)dma_adc; 			// Задаем адрес памяти - базовый адрес массива в RAM // dma_adc array_mb
	DMA1_Channel1->CCR &= ~DMA_CCR1_DIR; 				// Указываем направление передачи данных, из периферии в память
	DMA1_Channel1->CNDTR = DMA_BUFF_SIZE; 				// Количество пересылаемых значений
	DMA1_Channel1->CCR &= ~DMA_CCR1_PINC; 				// Адрес периферии не инкрементируем после каждой пересылки
	DMA1_Channel1->CCR |= DMA_CCR1_MINC; 				// Адрес памяти инкрементируем после каждой пересылки.
	DMA1_Channel1->CCR |= DMA_CCR1_PSIZE_0; 			// Размерность данных периферии - 16 бит
	DMA1_Channel1->CCR |= DMA_CCR1_MSIZE_0; 			// Размерность данных памяти - 16 бит
	DMA1_Channel1->CCR |= DMA_CCR1_PL; 					// Приоритет - очень высокий
	DMA1_Channel1->CCR |= DMA_CCR1_CIRC; 				// Разрешаем работу DMA в циклическом режиме
	DMA1_Channel1->CCR |= DMA_CCR1_EN; 					// Разрешаем работу 1-го канала DMA



	ADC1->SQR1 =  ADC_SQR1_L_2;		//	ADC_SQR1_L_0 |// 5 регулярных каналов для сканирования
	ADC1->SQR3 = ADC_SQR3_SQ2_0 | ADC_SQR3_SQ3_1 | ADC_SQR3_SQ4_0 | ADC_SQR3_SQ4_1 |  ADC_SQR3_SQ5_2;


	ADC1->SMPR2 = 0x00007FFF;							// время выборки 5-и каналов с начала


	//NVIC->ISER[0] |= NVIC_ISER_SETENA_18;				// разрешаем прерывание от АЦП
	//NVIC_EnableIRQ (ADC1_2_IRQn);						// разрешаем прерывание от АЦП

	//разрешаем прерывания по окончанию преобразования
	ADC1->CR1 |= ADC_CR1_EOCIE;

	ADC1->CR2 = ADC_CR2_EXTSEL; 						// Выбрать источником запуска разряд SWSTART
	ADC1->CR2 |= ADC_CR2_EXTTRIG; 						// Разрешить внешний запуск регулярного канала
	ADC1->CR2 |= ADC_CR2_CONT; 							// Включить режим непрерывного преобразования

	ADC1->CR1 |= ADC_CR1_SCAN; 							// Включить режим сканирования нескольких каналов

	//ADC1->CR1 |= ADC_CR1_DISCEN;						// Прерывистый режим
	ADC1->CR2 |= ADC_CR2_ADON; 							// Включить АЦП
	ADC1->CR2 |= ADC_CR2_ADON; 							// Включить АЦП
	ADC1->CR2 |= ADC_CR2_SWSTART;  						// Пуск преобразования регулярной группы

	ADC1->CR2 |=  ADC_CR2_DMA;                   		// Bit 8 DMA: Direct memory access mode (for single ADC mode)





	NVIC_EnableIRQ (DMA1_Channel1_IRQn);				// разрешаем прерывание первого канала дма
	DMA1_Channel1->CCR |= DMA_CCR1_TCIE;				// разрешаем прерывание по заполнению буфера
	DMA1_Channel1->CCR |= DMA_CCR1_HTIE;				// разрешаем прерывание по заполнению половины буфера




	for(;;)
	{

		array_mb[8]++;

		Modbus_slave();

	} // скобочка бесконечного цикла
} // скобочка mian
