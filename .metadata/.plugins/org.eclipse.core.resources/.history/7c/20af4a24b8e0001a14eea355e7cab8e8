#include "stm32f10x.h"
#include "modbus.h"


unsigned int delay_packet = 0;								// задержка между пакетами. будет равна 7, что значит 1,75 мс
char flag_UART_in = 0;										// флаг начала приёма посылки по UART
char swith_modbas = 0;										// переменная переключатель для разбора посылки

int 			array_modbas_in[255];						// буфер для приёма из уарта
int 			count_modbas_in 		= 0;				// счётчик кол-ва принятых байт
int 			array_modbas_out[255];						// буфер для передачи из уарта
int 			count_modbas_out 		= 0;				// счётчик кол-ва переданных байт
int 			buffer_index			= 0;				// счётчик для отправки
int 			count_transf_array 		= 0;				// счётчик для перегрузки массивов

unsigned short	array_mb[100]			= {};				// массив для хранения принятых/переданных слов

unsigned long 	crc_calc 				= 0;				// расчётная контрольная сумма
unsigned long 	adrr_var 				= 0;				// собраный адрес из массива принятого по сети. для сравнения.
unsigned long 	quantity_byte 			= 0;				// кол-во байт которое необходимо записать или считать по сети из памяти

unsigned int 	crc_read_low 			= 0;				// буферные переменные для сравнение контрольной суммы
unsigned int 	crc_read_high 			= 0;				//
unsigned int 	crc_calc_low 			= 0;				//
unsigned int 	crc_calc_high 			= 0;				//



// Обработчики прерываний

void TIM2_IRQHandler (void)						// обработчик таймера для всяких задержек
{
	unsigned short status;
	status = TIM2->SR;
	TIM2->SR = ~status;

	if(status & TIM_SR_UIF)
	{

		if(delay_packet != 0)					// отсчёт времени для слейва
		{
			delay_packet--;
		}

	}
}






void USART1_IRQHandler(void)
{
	unsigned short temp =  USART1->SR;
	USART1->SR = 0;

	 if (temp & USART_SR_RXNE)			// RXNE - что-то пришло, можно забирать. сбрасывается при чтении DR
		{

			array_modbas_in[(count_modbas_in & 0x0ff)] = USART1->DR;			// записываем байт в буферный массив для приёма.
			count_modbas_in++;										// увеличиваем счётчик байт в буфере


			delay_packet = 7;					// запускаем отсчёт 1,75 мс, каждый новый байт будет поддёргивать эту переменную. закончились байты - посылка принята.
			flag_UART_in = 1;					// флаг старта приёма посылки

			return;

		}

	 if(temp & USART_SR_TC)
	 {
		 USART1->CR1 	&= 	~(USART_CR1_TCIE); 		// выключаем прерывание по завершении передачи. Зачем? ... (злесь нужено включать приёмник, а в сварочнике тоже)

		 //GPIOC->BSRR =  GPIO_BSRR_BR12;				// записать 0 в GPIOA.12		// слушаем

		return;
	 }

	 if (temp & USART_SR_TXE)
	 {
		 buffer_index++;								// Увеличиваем индекс


		 USART1->DR = array_modbas_out[buffer_index];   // Берем данные из буффера.

		if(buffer_index == (count_modbas_out-1))  		// Вывели весь буффер?
			{
				USART1->CR1 	&= 	~(USART_CR1_TXEIE); 	// Запрещаем прерывание по опустошению - передача закончена
				USART1->CR1 	|= 	USART_CR1_TCIE; 		// включаем прерывание по завершении передачи
			}
	 }
}



void ADC1_2_IRQHandler(void)
{
    if(ADC1->SR & ADC_SR_EOC)
	{

	}

	ADC1->SR=0;	//сбрасываем все флаги в регистре статуса
}
